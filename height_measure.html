<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ARèº«é•·æ¸¬å®šç”»é¢</title>
    <link rel="stylesheet" href="vivi_ar_style.css"> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="toast">
    <span style="font-size:1.2em">ğŸ‰</span> ä¿å­˜ã—ã¾ã—ãŸ
</div>

<section id="camera-section">
    <div id="camera-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>
    <div id="status-badge" class="status-overlay warning">
        âš  2mã§è£œæ­£ãŒå¿…è¦ã§ã™
    </div>
</section>

<section id="controls-section">
    <div class="inputs-row">
        <div style="flex: 1;">
            <input id="name-input" type="text" placeholder="åå‰ (ä¾‹: ãŸãªã‹)">
        </div>
        <div style="flex: 1;">
            <select id="camera-select">
                <option value="environment">èƒŒé¢ã‚«ãƒ¡ãƒ©</option>
                <option value="user">å‰é¢ã‚«ãƒ¡ãƒ©</option>
            </select>
        </div>
    </div>

    <div class="result-display">
        <div style="display:flex; align-items:baseline;">
            <span id="height-val" class="height-value">--</span>
            <span class="height-unit">cm</span>
        </div>
        <div class="distance-info">
            è·é›¢: <span id="dist-val" class="distance-val">--</span> m<br>
            <span style="font-size:0.75rem; opacity:0.7;">(ç›®æ¨™: 2.00m)</span>
        </div>
    </div>

    <div class="action-grid">
        <button id="main-btn" class="ripple">
            <span>âš¡ 2mã§è£œæ­£ã‚’é–‹å§‹</span>
        </button>
        <button id="history-btn" class="sub-btn ripple">
            ğŸ“‹
        </button>
    </div>
</section>

<div id="history-modal" class="modal">
    <div class="modal-content">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-xl font-bold text-white">è¨ˆæ¸¬å±¥æ­´</h2>
            <button onclick="closeModal('history-modal')" class="text-gray-400 text-3xl p-2 hover:text-white">&times;</button>
        </div>
        <div style="overflow-x: auto; max-height: 40vh; overflow-y: auto;">
            <table id="history-table">
                <thead>
                <tr>
                    <th>åå‰</th>
                    <th>èº«é•·</th>
                    <th>æ—¥æ™‚</th>
                </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <button onclick="closeModal('history-modal')" class="w-full mt-6 p-4 bg-slate-700 rounded-xl font-bold text-white active:bg-slate-600 transition">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div id="photo-modal" class="modal">
    <div class="modal-content text-center">
        <h2 class="text-xl font-bold text-white mb-4">æ’®å½±å®Œäº†!</h2>
        <img id="photo-preview" class="w-full rounded-xl mb-6 border border-gray-600 shadow-lg">
        <button onclick="closeModal('photo-modal')" class="w-full p-4 bg-blue-600 rounded-xl font-bold text-white shadow-lg active:scale-95 transition">OK</button>
    </div>
</div>

<script>
    // ==========================================
    // ğŸ”Š Sound Manager (Web Audio API)
    // ==========================================
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    const Sound = {
        // ã‚¯ãƒªãƒƒã‚¯éŸ³ï¼ˆé«˜ã„ã€Œãƒ”ãƒƒã€ï¼‰
        click: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        },
        // æˆåŠŸéŸ³ï¼ˆã€Œãƒ”ãƒ­ãƒªãƒ³â™ªã€ï¼‰
        success: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);

            // 1éŸ³ç›®
            osc1.frequency.setValueAtTime(880, now); // A5
            osc1.start(now);
            osc1.stop(now + 0.1);

            // 2éŸ³ç›®
            osc2.frequency.setValueAtTime(1760, now + 0.1); // A6
            osc2.start(now + 0.1);
            osc2.stop(now + 0.4);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.4);
        },
        // ã‚·ãƒ£ãƒƒã‚¿ãƒ¼éŸ³ï¼ˆã€Œã‚«ã‚·ãƒ£ãƒƒã€ï¼šãƒã‚¤ã‚ºãƒãƒ¼ã‚¹ãƒˆï¼‰
        shutter: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const bufferSize = audioCtx.sampleRate * 0.1; // 0.1ç§’
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1; // ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚º
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }
    };

    // ==========================================
    // DOM & State
    // ==========================================
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const statusBadge = document.getElementById('status-badge');
    const heightVal = document.getElementById('height-val');
    const distVal = document.getElementById('dist-val');
    const mainBtn = document.getElementById('main-btn');
    const historyBtn = document.getElementById('history-btn');
    const nameInput = document.getElementById('name-input');
    const cameraSelect = document.getElementById('camera-select');
    const toast = document.getElementById('toast');

    let currentStream = null;
    let state = 'INIT'; // INIT -> CALIBRATING -> MEASURING
    let animationId = null;

    const TARGET_DIST = 2.0;
    const DEFAULT_FOV = 60;

    let Z_ref = null;
    let lastHeadZ = null;
    let heightHistory = [];
    const HISTORY_SIZE = 15;
    let autoCaptureLocked = false;

    let calibZBuffer = [];
    const CALIB_FRAMES = 30;

    // ==========================================
    // Initialization
    // ==========================================
    cameraSelect.onchange = (e) => {
        Sound.click();
        startCamera(e.target.value);
    };
    startCamera('environment');

    // Input Sound Feedback
    nameInput.addEventListener('focus', () => Sound.click());

    async function startCamera(facingMode) {
        try {
            if (currentStream) currentStream.getTracks().forEach(t => t.stop());
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }
            });
            currentStream = stream;
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            resetApp();
        } catch (e) {
            alert("ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
        }
    }
    function resizeCanvas() {
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
    }
    function resetApp() {
        state = 'INIT';
        Z_ref = null;
        heightVal.innerText = '--';
        distVal.innerText = '--';
        updateUI('INIT');
    }
    function updateUI(appState) {
        // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†é©ç”¨
        statusBadge.className = 'status-overlay';
        if (appState === 'INIT') {
            statusBadge.classList.add('warning');
            statusBadge.innerText = 'âš  2måœ°ç‚¹ã§è£œæ­£ã—ã¦ãã ã•ã„';
            mainBtn.innerHTML = '<span>âš¡ 2mã§è£œæ­£ã‚’é–‹å§‹</span>';
            mainBtn.classList.remove('recording');
        } else if (appState === 'CALIBRATING') {
            statusBadge.classList.add('warning');
            statusBadge.innerText = 'è£œæ­£ä¸­...å‹•ã‹ãªã„ã§';
            mainBtn.innerHTML = '<span>â³ è£œæ­£ä¸­...</span>';
        } else if (appState === 'MEASURING') {
            statusBadge.classList.add('ready');
            statusBadge.innerText = 'ğŸŸ¢ è¨ˆæ¸¬ä¸­';
            mainBtn.innerHTML = '<span>â¹ è¨ˆæ¸¬ã‚’åœæ­¢ï¼†ä¿å­˜</span>';
            mainBtn.classList.add('recording');
        }
    }
    // ==========================================
    // MediaPipe & Logic
    // ==========================================
    const pose = new Pose({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
    });
    pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);
    async function loop() {
        if (!video.videoWidth) return;
        await pose.send({ image: video });
        animationId = requestAnimationFrame(loop);
    }
    // --- Main Button Logic ---
    mainBtn.onclick = () => {
        Sound.click(); // Click sound
        if (state === 'INIT') {
            state = 'CALIBRATING';
            calibZBuffer = [];
            updateUI('CALIBRATING');
            if (!animationId) loop();
        } else if (state === 'MEASURING') {
            Sound.shutter(); // Shutter sound
            captureAndSave();
            resetApp();
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    };
    function onResults(results) {
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        if (!results.poseLandmarks) return;
        const landmarks = results.poseLandmarks;
        const currentHeadZ = Math.abs(landmarks[0].z);
        // 1. Calibration
        if (state === 'CALIBRATING') {
            calibZBuffer.push(currentHeadZ);
            // Draw progress ring
            const cx = overlay.width / 2;
            const cy = overlay.height / 2;
            const pct = calibZBuffer.length / CALIB_FRAMES;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(cx, cy, 50, -Math.PI/2, (Math.PI*2*pct) - Math.PI/2);
            ctx.stroke();
            if (calibZBuffer.length >= CALIB_FRAMES) {
                Z_ref = calibZBuffer.reduce((a, b) => a + b, 0) / calibZBuffer.length;
                state = 'MEASURING';
                heightHistory = [];
                autoCaptureLocked = false;
                Sound.success(); // Calibration done sound
                updateUI('MEASURING');
            }
            return;
        }
        // 2. Measuring
        if (state === 'MEASURING') {
            const distM = (TARGET_DIST * Z_ref) / currentHeadZ;
            distVal.innerText = distM.toFixed(2);
            if (Math.abs(distM - TARGET_DIST) < 0.1) {
                distVal.style.color = '#4ade80';
            } else {
                distVal.style.color = '#94a3b8'; // gray
            }
            const heightData = calculateHeight(landmarks, distM);
            if (heightData) {
                heightHistory.push(heightData.val);
                if (heightHistory.length > HISTORY_SIZE) heightHistory.shift();
                const smoothH = heightHistory.reduce((a,b)=>a+b,0) / heightHistory.length;
                heightVal.innerText = smoothH.toFixed(1);
                drawAR(heightData.top, heightData.bottom, smoothH);
                // Auto Capture
                const isStable = lastHeadZ && Math.abs(currentHeadZ - lastHeadZ) < 0.02;
                const isDistOK = Math.abs(distM - TARGET_DIST) < 0.05;
                if (!autoCaptureLocked && isStable && isDistOK && heightHistory.length >= HISTORY_SIZE) {
                    autoCaptureLocked = true;
                    statusBadge.innerText = "ğŸ“¸ è‡ªå‹•æ’®å½±...";
                    mainBtn.innerText = "ğŸ“¸ ä¿å­˜ä¸­...";
                    setTimeout(() => {
                        Sound.shutter(); // Auto Shutter Sound
                        captureAndSave();
                        resetApp();
                        cancelAnimationFrame(animationId);
                        animationId = null;
                        showToast();
                    }, 600);
                }
                lastHeadZ = currentHeadZ;
            }
        }
    }
    function calculateHeight(lm, dist) {
        const ankleY = (lm[27].y + lm[28].y) / 2;
        const eyeY = (lm[2].y + lm[5].y) / 2;
        if (ankleY > 0.98 || eyeY < 0.02) return null;
        const hipY = (lm[23].y + lm[24].y) / 2;
        const headTopY = eyeY - ((hipY - eyeY) * 0.5);
        const footBottomY = ankleY + 0.03;
        const pxHeight = (footBottomY - headTopY) * overlay.height;
        const realViewHeight = 2 * dist * Math.tan((DEFAULT_FOV / 2) * Math.PI / 180);
        const hCm = (pxHeight / overlay.height) * realViewHeight * 100;
        return { val: hCm, top: headTopY * overlay.height, bottom: footBottomY * overlay.height };
    }
    function drawAR(top, bottom, val) {
        const x = overlay.width / 2;
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.9)'; // Sky Blue
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, bottom);
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(x, top, 6, 0, 2*Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(x, bottom, 6, 0, 2*Math.PI); ctx.fill();
        // æ•°å€¤ã‚’ARä¸Šã«ã‚‚è¡¨ç¤ºã™ã‚‹å ´åˆ
        /*
        ctx.font = "bold 32px Inter";
        ctx.fillText(val.toFixed(1) + "cm", x + 20, (top + bottom) / 2);
        */
    }
    // ==========================================
    // Storage & Modal
    // ==========================================
    function captureAndSave() {
        const name = nameInput.value || "åç„¡ã—";
        const h = parseFloat(heightVal.innerText);
        if (isNaN(h)) return;
        const c = document.createElement('canvas');
        c.width = video.videoWidth;
        c.height = video.videoHeight;
        const cx = c.getContext('2d');
        cx.drawImage(video, 0, 0);
        cx.fillStyle = "rgba(0,0,0,0.5)";
        cx.fillRect(0, c.height - 120, c.width, 120);
        cx.fillStyle = "white";
        cx.font = "bold 48px sans-serif";
        cx.fillText(`${name}: ${h}cm`, 40, c.height - 50);
        const url = c.toDataURL('image/png');
        document.getElementById('photo-preview').src = url;
        document.getElementById('photo-modal').classList.add('open');
        Sound.success(); // Success Sound
        showToast();
        fetch('/api/measurements', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ name: name, heightCm: h })
        }).catch(e => console.error(e));
    }
    historyBtn.onclick = () => {
        Sound.click();
        fetch('/api/measurements').then(r=>r.json()).then(data => {
            const tbody = document.querySelector('#history-table tbody');
            tbody.innerHTML = '';
            if (data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 p-4">å±¥æ­´ãªã—</td></tr>';
            }
            data.reverse().forEach(d => {
                const date = new Date(d.timestamp);
                const ds = `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
                tbody.innerHTML += `<tr>
                    <td class="font-bold">${d.name}</td>
                    <td class="text-blue-400 font-bold text-lg">${d.heightCm.toFixed(1)}</td>
                    <td class="text-gray-400 text-xs">${ds}</td>
                </tr>`;
            });
            document.getElementById('history-modal').classList.add('open');
        });
    };
    function closeModal(id) {
        Sound.click();
        document.getElementById(id).classList.remove('open');
    }
    function showToast() {
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }
</script>
</body>
</html>
 

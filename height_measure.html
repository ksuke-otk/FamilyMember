<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Height Measure</title>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@500;700&display=swap" rel="stylesheet">

    <style>
        /* =========================================
           „Éô„Éº„Çπ„Çπ„Çø„Ç§„É´
           ========================================= */
        body {
            background-color: #0f172a; /* Slate 900 */
            color: #f8fafc;
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            height: 100dvh; /* „ÉÄ„Ç§„Éä„Éü„ÉÉ„ÇØ„Éì„É•„Éº„Éù„Éº„Éà„ÅÆÈ´ò„Åï */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´Á¶ÅÊ≠¢ */
        }

        /* =========================================
           „Ç´„É°„É©„Çª„ÇØ„Ç∑„Éß„É≥ (‰∏äÈÉ® 60%)
           ========================================= */
        #camera-section {
            position: relative;
            flex: 6; /* ÁîªÈù¢„ÅÆ6Ââ≤ */
            background: #000;
            overflow: hidden;
            border-bottom-left-radius: 24px;
            border-bottom-right-radius: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        #camera-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #video, #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„ÉÉ„Ç∏ÔºàÁîªÈù¢‰∏ä„ÅÆË≠¶Âëä„Å™„Å©Ôºâ */
        .status-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 9999px;
            font-size: 0.9rem;
            font-weight: bold;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status-overlay.warning {
            border-color: #f59e0b; /* Amber */
            color: #fcd34d;
        }

        .status-overlay.ready {
            border-color: #22c55e; /* Green */
            color: #4ade80;
            background: rgba(20, 83, 45, 0.8);
        }

        /* =========================================
           „Ç≥„É≥„Éà„É≠„Éº„É´„Çª„ÇØ„Ç∑„Éß„É≥ (‰∏ãÈÉ® 40%)
           ========================================= */
        #controls-section {
            flex: 4;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: #1e293b; /* Slate 800 */
        }

        /* ÂÖ•Âäõ„Ç®„É™„Ç¢ */
        .inputs-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }

        input, select {
            width: 100%;
            padding: 12px;
            background: #334155;
            border: 1px solid #475569;
            color: white;
            border-radius: 12px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }

        input:focus, select:focus {
            border-color: #3b82f6;
        }

        /* ÁµêÊûúË°®Á§∫„Ç®„É™„Ç¢ */
        .result-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0f172a;
            padding: 15px 20px;
            border-radius: 16px;
            border: 1px solid #334155;
            margin: 10px 0;
        }

        .height-value {
            font-size: 2.5rem;
            font-weight: 800;
            font-feature-settings: "tnum";
            color: #38bdf8; /* Sky Blue */
        }

        .height-unit {
            font-size: 1rem;
            color: #94a3b8;
            margin-left: 4px;
        }

        .distance-info {
            text-align: right;
            font-size: 0.9rem;
            color: #94a3b8;
            line-height: 1.4;
        }

        .distance-val {
            font-weight: bold;
            font-feature-settings: "tnum";
            color: white;
        }

        /* „Ç¢„ÇØ„Ç∑„Éß„É≥„Éú„Çø„É≥„Ç®„É™„Ç¢ */
        .action-grid {
            display: flex;
            gap: 12px;
            height: 64px;
        }

        button {
            border: none;
            cursor: pointer;
            font-family: inherit;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:active {
            transform: scale(0.96);
        }

        #main-btn {
            flex: 3;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border-radius: 16px;
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #main-btn.recording {
            background: linear-gradient(135deg, #ef4444, #dc2626); /* Red for Stop */
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
        }

        .sub-btn {
            flex: 1;
            background: #334155;
            color: #e2e8f0;
            border-radius: 16px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* =========================================
           „É¢„Éº„ÉÄ„É´ & „Éà„Éº„Çπ„Éà
           ========================================= */
        .modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            padding: 20px;
        }

        .modal.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: #1e293b;
            width: 100%;
            max-width: 400px;
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border: 1px solid #334155;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal.open .modal-content {
            transform: scale(1);
        }

        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: #10b981;
            color: white;
            padding: 12px 24px;
            border-radius: 99px;
            font-weight: bold;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 200;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* „ÉÜ„Éº„Éñ„É´„Çπ„Çø„Ç§„É´ */
        #history-table {
            width: 100%;
            border-collapse: collapse;
            color: #cbd5e1;
        }
        #history-table th {
            text-align: left;
            padding: 8px;
            border-bottom: 2px solid #334155;
            color: #94a3b8;
            font-size: 0.85rem;
        }
        #history-table td {
            padding: 12px 8px;
            border-bottom: 1px solid #334155;
        }
    </style>
</head>
<body>

<div id="toast">
    <span style="font-size:1.2em">üéâ</span> ‰øùÂ≠ò„Åó„Åæ„Åó„Åü
</div>

<section id="camera-section">
    <div id="camera-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>
    <div id="status-badge" class="status-overlay warning">
        ‚ö† 2m„ÅßË£úÊ≠£„ÅåÂøÖË¶Å„Åß„Åô
    </div>
</section>

<section id="controls-section">
    <div class="inputs-row">
        <div style="flex: 1;">
            <input id="name-input" type="text" placeholder="ÂêçÂâç (‰æã: „Åü„Å™„Åã)">
        </div>
        <div style="flex: 1;">
            <select id="camera-select">
                <option value="environment">ËÉåÈù¢„Ç´„É°„É©</option>
                <option value="user">ÂâçÈù¢„Ç´„É°„É©</option>
            </select>
        </div>
    </div>

    <div class="result-display">
        <div style="display:flex; align-items:baseline;">
            <span id="height-val" class="height-value">--</span>
            <span class="height-unit">cm</span>
        </div>
        <div class="distance-info">
            Ë∑ùÈõ¢: <span id="dist-val" class="distance-val">--</span> m<br>
            <span style="font-size:0.75rem; opacity:0.7;">(ÁõÆÊ®ô: 2.00m)</span>
        </div>
    </div>

    <div class="action-grid">
        <button id="main-btn" class="ripple">
            <span>‚ö° 2m„ÅßË£úÊ≠£„ÇíÈñãÂßã</span>
        </button>
        <button id="history-btn" class="sub-btn ripple">
            üìã
        </button>
    </div>
</section>

<div id="history-modal" class="modal">
    <div class="modal-content">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-xl font-bold text-white">Ë®àÊ∏¨Â±•Ê≠¥</h2>
            <button onclick="closeModal('history-modal')" class="text-gray-400 text-3xl p-2 hover:text-white">&times;</button>
        </div>
        <div style="overflow-x: auto; max-height: 40vh; overflow-y: auto;">
            <table id="history-table">
                <thead>
                <tr>
                    <th>ÂêçÂâç</th>
                    <th>Ë∫´Èï∑</th>
                    <th>Êó•ÊôÇ</th>
                </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <button onclick="closeModal('history-modal')" class="w-full mt-6 p-4 bg-slate-700 rounded-xl font-bold text-white active:bg-slate-600 transition">Èñâ„Åò„Çã</button>
    </div>
</div>

<div id="photo-modal" class="modal">
    <div class="modal-content text-center">
        <h2 class="text-xl font-bold text-white mb-4">ÊíÆÂΩ±ÂÆå‰∫Ü!</h2>
        <img id="photo-preview" class="w-full rounded-xl mb-6 border border-gray-600 shadow-lg">
        <button onclick="closeModal('photo-modal')" class="w-full p-4 bg-blue-600 rounded-xl font-bold text-white shadow-lg active:scale-95 transition">OK</button>
    </div>
</div>

<script>
    // ==========================================
    // üîä Sound Manager (Web Audio API)
    // ==========================================
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    const Sound = {
        // „ÇØ„É™„ÉÉ„ÇØÈü≥ÔºàÈ´ò„ÅÑ„Äå„Éî„ÉÉ„ÄçÔºâ
        click: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        },
        // ÊàêÂäüÈü≥Ôºà„Äå„Éî„É≠„É™„É≥‚ô™„ÄçÔºâ
        success: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);

            // 1Èü≥ÁõÆ
            osc1.frequency.setValueAtTime(880, now); // A5
            osc1.start(now);
            osc1.stop(now + 0.1);

            // 2Èü≥ÁõÆ
            osc2.frequency.setValueAtTime(1760, now + 0.1); // A6
            osc2.start(now + 0.1);
            osc2.stop(now + 0.4);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.4);
        },
        // „Ç∑„É£„ÉÉ„Çø„ÉºÈü≥Ôºà„Äå„Ç´„Ç∑„É£„ÉÉ„ÄçÔºö„Éé„Ç§„Ç∫„Éê„Éº„Çπ„ÉàÔºâ
        shutter: () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const bufferSize = audioCtx.sampleRate * 0.1; // 0.1Áßí
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1; // „Éõ„ÉØ„Ç§„Éà„Éé„Ç§„Ç∫
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }
    };

    // ==========================================
    // DOM & State
    // ==========================================
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const statusBadge = document.getElementById('status-badge');
    const heightVal = document.getElementById('height-val');
    const distVal = document.getElementById('dist-val');
    const mainBtn = document.getElementById('main-btn');
    const historyBtn = document.getElementById('history-btn');
    const nameInput = document.getElementById('name-input');
    const cameraSelect = document.getElementById('camera-select');
    const toast = document.getElementById('toast');

    let currentStream = null;
    let state = 'INIT'; // INIT -> CALIBRATING -> MEASURING
    let animationId = null;

    const TARGET_DIST = 2.0;
    const DEFAULT_FOV = 60;

    let Z_ref = null;
    let lastHeadZ = null;
    let heightHistory = [];
    const HISTORY_SIZE = 15;
    let autoCaptureLocked = false;

    let calibZBuffer = [];
    const CALIB_FRAMES = 30;

    // ==========================================
    // Initialization
    // ==========================================
    cameraSelect.onchange = (e) => {
        Sound.click();
        startCamera(e.target.value);
    };
    startCamera('environment');

    // Input Sound Feedback
    nameInput.addEventListener('focus', () => Sound.click());

    async function startCamera(facingMode) {
        try {
            if (currentStream) currentStream.getTracks().forEach(t => t.stop());
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }
            });
            currentStream = stream;
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            resetApp();
        } catch (e) {
            alert("„Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + e.message);
        }
    }
    function resizeCanvas() {
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
    }
    function resetApp() {
        state = 'INIT';
        Z_ref = null;
        heightVal.innerText = '--';
        distVal.innerText = '--';
        updateUI('INIT');
    }
    function updateUI(appState) {
        // „ÇØ„É©„Çπ„Çí„É™„Çª„ÉÉ„Éà„Åó„Å¶ÂÜçÈÅ©Áî®
        statusBadge.className = 'status-overlay';
        if (appState === 'INIT') {
            statusBadge.classList.add('warning');
            statusBadge.innerText = '‚ö† 2mÂú∞ÁÇπ„ÅßË£úÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
            mainBtn.innerHTML = '<span>‚ö° 2m„ÅßË£úÊ≠£„ÇíÈñãÂßã</span>';
            mainBtn.classList.remove('recording');
        } else if (appState === 'CALIBRATING') {
            statusBadge.classList.add('warning');
            statusBadge.innerText = 'Ë£úÊ≠£‰∏≠...Âãï„Åã„Å™„ÅÑ„Åß';
            mainBtn.innerHTML = '<span>‚è≥ Ë£úÊ≠£‰∏≠...</span>';
        } else if (appState === 'MEASURING') {
            statusBadge.classList.add('ready');
            statusBadge.innerText = 'üü¢ Ë®àÊ∏¨‰∏≠';
            mainBtn.innerHTML = '<span>‚èπ Ë®àÊ∏¨„ÇíÂÅúÊ≠¢ÔºÜ‰øùÂ≠ò</span>';
            mainBtn.classList.add('recording');
        }
    }
    // ==========================================
    // MediaPipe & Logic
    // ==========================================
    const pose = new Pose({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
    });
    pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);
    async function loop() {
        if (!video.videoWidth) return;
        await pose.send({ image: video });
        animationId = requestAnimationFrame(loop);
    }
    // --- Main Button Logic ---
    mainBtn.onclick = () => {
        Sound.click(); // Click sound
        if (state === 'INIT') {
            state = 'CALIBRATING';
            calibZBuffer = [];
            updateUI('CALIBRATING');
            if (!animationId) loop();
        } else if (state === 'MEASURING') {
            Sound.shutter(); // Shutter sound
            captureAndSave();
            resetApp();
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    };
    function onResults(results) {
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        if (!results.poseLandmarks) return;
        const landmarks = results.poseLandmarks;
        const currentHeadZ = Math.abs(landmarks[0].z);
        // 1. Calibration
        if (state === 'CALIBRATING') {
            calibZBuffer.push(currentHeadZ);
            // Draw progress ring
            const cx = overlay.width / 2;
            const cy = overlay.height / 2;
            const pct = calibZBuffer.length / CALIB_FRAMES;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(cx, cy, 50, -Math.PI/2, (Math.PI*2*pct) - Math.PI/2);
            ctx.stroke();
            if (calibZBuffer.length >= CALIB_FRAMES) {
                Z_ref = calibZBuffer.reduce((a, b) => a + b, 0) / calibZBuffer.length;
                state = 'MEASURING';
                heightHistory = [];
                autoCaptureLocked = false;
                Sound.success(); // Calibration done sound
                updateUI('MEASURING');
            }
            return;
        }
        // 2. Measuring
        if (state === 'MEASURING') {
            const distM = (TARGET_DIST * Z_ref) / currentHeadZ;
            distVal.innerText = distM.toFixed(2);
            if (Math.abs(distM - TARGET_DIST) < 0.1) {
                distVal.style.color = '#4ade80';
            } else {
                distVal.style.color = '#94a3b8'; // gray
            }
            const heightData = calculateHeight(landmarks, distM);
            if (heightData) {
                heightHistory.push(heightData.val);
                if (heightHistory.length > HISTORY_SIZE) heightHistory.shift();
                const smoothH = heightHistory.reduce((a,b)=>a+b,0) / heightHistory.length;
                heightVal.innerText = smoothH.toFixed(1);
                drawAR(heightData.top, heightData.bottom, smoothH);
                // Auto Capture
                const isStable = lastHeadZ && Math.abs(currentHeadZ - lastHeadZ) < 0.02;
                const isDistOK = Math.abs(distM - TARGET_DIST) < 0.05;
                if (!autoCaptureLocked && isStable && isDistOK && heightHistory.length >= HISTORY_SIZE) {
                    autoCaptureLocked = true;
                    statusBadge.innerText = "üì∏ Ëá™ÂãïÊíÆÂΩ±...";
                    mainBtn.innerText = "üì∏ ‰øùÂ≠ò‰∏≠...";
                    setTimeout(() => {
                        Sound.shutter(); // Auto Shutter Sound
                        captureAndSave();
                        resetApp();
                        cancelAnimationFrame(animationId);
                        animationId = null;
                        showToast();
                    }, 600);
                }
                lastHeadZ = currentHeadZ;
            }
        }
    }
    function calculateHeight(lm, dist) {
        const ankleY = (lm[27].y + lm[28].y) / 2;
        const eyeY = (lm[2].y + lm[5].y) / 2;
        if (ankleY > 0.98 || eyeY < 0.02) return null;
        const hipY = (lm[23].y + lm[24].y) / 2;
        const headTopY = eyeY - ((hipY - eyeY) * 0.5);
        const footBottomY = ankleY + 0.03;
        const pxHeight = (footBottomY - headTopY) * overlay.height;
        const realViewHeight = 2 * dist * Math.tan((DEFAULT_FOV / 2) * Math.PI / 180);
        const hCm = (pxHeight / overlay.height) * realViewHeight * 100;
        return { val: hCm, top: headTopY * overlay.height, bottom: footBottomY * overlay.height };
    }
    function drawAR(top, bottom, val) {
        const x = overlay.width / 2;
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.9)'; // Sky Blue
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, bottom);
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(x, top, 6, 0, 2*Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(x, bottom, 6, 0, 2*Math.PI); ctx.fill();
        // Êï∞ÂÄ§„ÇíAR‰∏ä„Å´„ÇÇË°®Á§∫„Åô„ÇãÂ†¥Âêà
        /*
        ctx.font = "bold 32px Inter";
        ctx.fillText(val.toFixed(1) + "cm", x + 20, (top + bottom) / 2);
        */
    }
    // ==========================================
    // Storage & Modal
    // ==========================================
    function captureAndSave() {
        const name = nameInput.value || "ÂêçÁÑ°„Åó";
        const h = parseFloat(heightVal.innerText);
        if (isNaN(h)) return;
        const c = document.createElement('canvas');
        c.width = video.videoWidth;
        c.height = video.videoHeight;
        const cx = c.getContext('2d');
        cx.drawImage(video, 0, 0);
        cx.fillStyle = "rgba(0,0,0,0.5)";
        cx.fillRect(0, c.height - 120, c.width, 120);
        cx.fillStyle = "white";
        cx.font = "bold 48px sans-serif";
        cx.fillText(`${name}: ${h}cm`, 40, c.height - 50);
        const url = c.toDataURL('image/png');
        document.getElementById('photo-preview').src = url;
        document.getElementById('photo-modal').classList.add('open');
        Sound.success(); // Success Sound
        showToast();
        fetch('/api/measurements', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ name: name, heightCm: h })
        }).catch(e => console.error(e));
    }
    historyBtn.onclick = () => {
        Sound.click();
        fetch('/api/measurements').then(r=>r.json()).then(data => {
            const tbody = document.querySelector('#history-table tbody');
            tbody.innerHTML = '';
            if (data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 p-4">Â±•Ê≠¥„Å™„Åó</td></tr>';
            }
            data.reverse().forEach(d => {
                const date = new Date(d.timestamp);
                const ds = `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
                tbody.innerHTML += `<tr>
                    <td class="font-bold">${d.name}</td>
                    <td class="text-blue-400 font-bold text-lg">${d.heightCm.toFixed(1)}</td>
                    <td class="text-gray-400 text-xs">${ds}</td>
                </tr>`;
            });
            document.getElementById('history-modal').classList.add('open');
        });
    };
    function closeModal(id) {
        Sound.click();
        document.getElementById(id).classList.remove('open');
    }
    function showToast() {
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }
</script>
</body>
</html>
 